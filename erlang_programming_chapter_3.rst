3 Erlangの逐次処理
==================

Erlangで逐次処理プログラムを取り扱うとき、Prologや関数型言語のML、Haskellなどに
備わっている機能が、どのようにErlangに影響を与えているか理解できる。
この章では、それらの機能について説明している。


3.1 条件評価
------------

Erlangには3種類の条件評価があり、

- 関数::

    test_func(0) -> 0;
    test_func(N) -> N + 1.

- case::

    case 条件式 of ->
        パターン1 -> 式1-1, 式1-2, .. ;
        パターン2 -> 式2-1, 式2-2, .. ;
        ... ;
        パターンn -> 式n-1, 式n-2, .. ;
    end

  関数の条件評価とよく似ている。

- if::

    if
        ガード1 -> 式1-1, 式1-2, .. ;
        ガード2 -> 式2-1, 式2-2, .. ;
        ... ;
        ガードn -> 式n-1, 式n-2, .. ;
    end

3.1.1 case構成要素
~~~~~~~~~~~~~~~~~~

case式の解説と、予防的プログラミングにcase式を使うことは「お勧めできない」とある。
その代わりに「no cause節エラー」で落とせ。
予防的プログラミングとは::

    foo(X) ->
        case X of
            x -> 1;
            y -> 2;
            Other -> {error, unknown}
        end.


3.1.2 変数のスコープ
~~~~~~~~~~~~~~~~~~~~

1. 関数の引数で定義された変数はその関数のなか全てで、
2. 関数の中で定義された変数は、その定義以降の任意の箇所で

利用することができる。
変数を宣言するまえに、その変数を使うようなコードはコンパイルエラーになる。


3.1.3 if構成要素
~~~~~~~~~~~~~~~~

caseと似てるけど、条件式が無く、ガード式で分岐する。::

    if
        ガード1 -> 式1-1, 式1-2, .. ;
        ガード2 -> 式2-1, 式2-2, .. ;
        ... ;
        ガードn -> 式n-1, 式n-2, .. ;
    end


3.2 ガード
----------

制約を付加する式で、whenに続けて記述する。

::

    f(0) -> 1;
    f(N) -> N * f(N-1).

    ↓

         vvvvvv
    f(N) when N > 0 -> N * f(N-1);
    f(0) -> 1.

ガード式は以下の要素から構成される。

- 束縛済みの変数
- リテラルのErlang項。数値、アトム、組、リストなどを含みデータ値を表すもの。
- 型テスト。is_binary、is_atom、is_boolean、is_tupleなど。
- 項の比較。==、=/=、<、>など。
- 算術式
- ブール式
- 組み込みのガード関数

ガードには副作用を持たせないことを保証するため、ユーザ定義の関数は使用できない。


3.3 組み込み関数
----------------

- BIFって略されるよ。
- 標準の組み込み関数は接頭辞なしで使える。
- Cで書かれることが多いので、効率よい。


3.3.1 オブジェクトへのアクセスと検査
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

多くの組み込み関数はリストや組など組み込みの型を取り扱う。

- hd/1
- tl1/
- length/1
- tuple_size/1
- element/2
- setelement/2
- erlang:append_element/2


3.3.2 型変換
~~~~~~~~~~~~

型変換の組み込み関数があります。


3.3.3 プロセス辞書
~~~~~~~~~~~~~~~~~~

プロセスグローバルな変数の格納領域を使用することができる、が、
*はげしくお勧めしない。*


3.3.4 メタプログラミング
~~~~~~~~~~~~~~~~~~~~~~~~

apply/3を使うと、メタプログラミングができるよ。::

    Module = exlamples,
    Function = even,
    Arguments = [10],
    apply(Module, Function, Arguments).

    ↓

    examples:even(10).


3.3.5 プロセス、ポート、分散処理、およびシステム情報
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

4章で並列処理に関わる組み込み関数を、
低レベルなシステム情報を取得するやつはドキュメントに書いてある。


3.3.6 入出力
~~~~~~~~~~~~

ioモジュールで副作用のある入出力を扱うことができる。
io:format/2はよく使うよね。


3.4 再帰
--------

::

    sum([]) -> 0;
    sum([Head | Tail]) -> Head + sum(Tail).


3.4.1 末尾再帰関数
~~~~~~~~~~~~~~~~~~

::

    sum([]) -> 0;
    sum(List) -> sum_acc(List, 0).

    sum_acc([], Sum) -> Sum;
    sum_acc([Head | Tail], Sum) -> sum_acc(Tail, Head+Sum).

スタックフレームに値を保持しないので、効率はいい。
ただし、コンパイラが賢くなったので、末尾再帰な関数の方が
非末尾再帰な関数に比べ常に効率とはいえなくなった。


3.4.2 末尾呼び出し再帰の最適化
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

引き続き末尾再帰のお話。末尾再帰関数の作り方。


3.4.3 繰り返し処理と再帰関数との比較
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

手続き型言語のfor文って末尾再帰関数に書き換えられるよね。


3.5 実行時エラー
----------------

Erlangは実行時エラーをシステムが起こします。
パターンマッチ失敗のエラーは平常時でもよく使う。


3.6 エラーの処理
----------------

エラーは発生するだけではなく捕捉して、そのプロセスが
終了することを防ぐこともできます。


3.6.1 try … catchの利用
~~~~~~~~~~~~~~~~~~~~~~~~

::

    try 式 of
        パターン1 [when ガード1] -> 式1; 
        パターンN [when ガードN] -> 式N 
    catch
        [クラス1]例外パターン1 [when 例外ガード1] -> 例外式1;
        [クラスN]例外パターンN [when 例外ガードN] -> 例外式N
    end

実行時エラーはクラス(型)をもっているので、それによって
パタンマッチすることができる。

throw/1による任意の例外でのジャンプもできる。


3.6.2 catchの利用
~~~~~~~~~~~~~~~~~

昔はtry … catch式が無かったので、古いコードではcatch式を
使っているものもあるので覚えておきましょう。


3.7 ライブラリモジュール
------------------------

組み込み関数以外にもErlang処理系と一緒に配布されている
モジュールがあるので、その探しかたを説明する。


3.7.1 ドキュメント
~~~~~~~~~~~~~~~~~~

HTML版のものや、erl -man Moduleでマニュアルが読める。


3.7.2 有用なモジュール
~~~~~~~~~~~~~~~~~~~~~~

Erlangモジュール、これだけは

- array 配列
- calendar 時間を日付に変換
- dict 辞書
- erlang 汎用組み込み関数
- file ファイルIO
- filename ファイルシステム操作
- io 入出力
- lists リスト操作
- math 数学的な関数
- queue FIFOキュー
- random 疑似乱数
- string 文字列処理
- timer 時間


3.8 デバッガ
------------

debug_infoフラグ付きでコンパイルしたモジュールはデバッガで
デバッグすることができる。

- コマンドライン::

    erlc +debug_info hoge.erl

- Erlangシェル::

    c(Module, [debug_info]).

- デバッガ起動::

    debugger:start().


3.9 エクササイズ
----------------

Let's try it :-]
